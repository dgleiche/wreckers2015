#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     nothing,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     BR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     grabber,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     arm,           tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    sGyro,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    sArm,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    rServo,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    lServo,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#include "drivers/hitechnic-gyro.h"

#include "ref/teleop_ref.h"

////////Function Prototypes
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

void grabberServoPos(int val) {
	servo[lServo] = val;
	servo[rServo] = 255-val;
}

////////Tasks
task btnListener() {
	bool grabCylinderDown = false;
	bool pressed3 = false;

	bool armServoDown = false;
	bool pressed1 = false;

	while(true) {
		getJoystickSettings(joystick);

		//Elevator
		if (joy1Btn(7))
			motor[elevator] = -50;
		else if (joy1Btn(8))
			motor[elevator] = 50;
		else
			motor[elevator] = 0;

		//Elevator Arm
		if (joy1Btn(5))
			motor[arm] = -100;
		else if (joy1Btn(6))
			motor[arm] = 100;
		else
			motor[arm] = 0;

		if (joy1Btn(1)) {
			if (!pressed1) {
				if (!armServoDown) {
					armServoDown = true;
					servo[sArm] = 180;
				}
				else {
					armServoDown = false;
					servo[sArm] = 0;
				}
			}
			pressed1 = true;
		}
		else {
			pressed1 = false;
		}

		//Left and right cylinder grabbers
		if (joy1Btn(3)) {
			if (!pressed3) {
				if (!grabCylinderDown) {
					grabCylinderDown = true;
					grabberServoPos(GRABBERDOWN);
				}
				else {
					grabCylinderDown = false;
					grabberServoPos(GRABBERUP);
				}
			}
			pressed3 = true;
		}
		else {
			pressed3 = false;
		}

		//Grabber intake/outake
		if (joy1Btn(2))
			motor[grabber] = 100;
		else if (joy1Btn(4))
			motor[grabber] = -100;
		else
			motor[grabber] = 0;


	}
}


task main()
{
	//Initialize components
	setMotor(0, 0, 0, 0);

	grabberServoPos(GRABBERUP);

	servo[sArm] = 0;

	servo[sGyro] = GYRODOWN;

	//Init Gyro
	wait1Msec(500);
	HTGYROstartCal(gyro);

	//Wait for Comp. to start
#ifdef wait_for_start
	waitForStart();
#endif

	StartTask(btnListener);

	//Main loop
	while(true) {

		/*getJoystickSettings(joystick);

		/////////////////////////////JOYSTICK MOVEMENT//////////////////////////

		//Vals on joy1_x/y1 will be translatational
		float tX = joystick.joy1_x1;
		float tY = joystick.joy1_y1;

		//Val on joy1_x2 will be for x rotation
		float rotX = joystick.joy1_x2;


		//Var to hold motor vals
		ms *m;
		//clearDebugStream();

		//No unwanted movement
		m = (abs(tX) > THRESHOLD || abs(tY) > THRESHOLD || abs(rotX) > THRESHOLD) ? calcJoyMove(tX, tY, rotX) : setms(0, 0, 0, 0);

		writeDebugStreamLine("%d", degreesToRadians(HTGYROreadRot(gyro)));
*/
	bool invPower = false; //set true if you want the front to be back
		bool yStickOnlyVert = true; //Y stick only controls vertical movement

		getJoystickSettings(joystick);

		//Create instance of the mVals object (defined as a typedef)
		mVals *m;

		//If the joystick passes movement THRESHOLD render value
		if (abs(joystick.joy1_x2) > THRESHOLD) {
			m = joyMove(joystick.joy1_x2, joystick.joy1_y1);
		}
		else if (abs(joystick.joy1_y1) > THRESHOLD && abs(joystick.joy1_x2) < THRESHOLD && yStickOnlyVert) {
			m = joyMove(0, joystick.joy1_y1);
		}
		else if (!yStickOnlyVert && (abs(joystick.joy1_y1) > THRESHOLD) || (abs(joystick.joy1_x1) > THRESHOLD)) {
			m = joyMove(joystick.joy1_x1, joystick.joy1_y1);
		}

		//Definite movements of d-pad
		else if (joystick.joy1_TopHat != -1) { //It ain't centered

		//A switch statement essentially runs a portion of code when the value passed to switch is present in a case (defaults to default)
			switch (joystick.joy1_TopHat) {
				case 0: //Top
					m = forward();
					break;

				case 2: //Right
					m = rotR();
					break;

				case 4: //Bottom
					m = backward();
					break;

				case 6: //Left
					m = rotL();
					break;

				default:
					break; //In diagonal quadrants: Maybe make code for later?
			}
		}
		else {
			//Nothing is pressed: stop the motors
			m = setMVals(0, 0, 0, 0);
		}

		if (invPower) {
			//If I want to inverse the powers (variable at the beginning)
			//Quick note: when retrieving values of an object (typedef), reference them from within the object with a ->
			m = setMVals(-m->fl, -m->fr, -m->bl, -m->br); //Makes top bottom through inversion
		}

		////////////////////////D PAD MOVEMENT//////////////////////////////
		//D Pad will always override joystick
		//Check to see if top hat isnt centered (centered yields -1
		if (joystick.joy1_TopHat != -1) {

			switch (joystick.joy1_TopHat) {
			case 0: //Top
				m = forward(100);
				break;

			case 1: //Top Right
				//m = diagFR(100);
				break;

			case 2: //Right
				//m = strafeR(100);
				m = rotR(100);
				break;

			case 3: //Bottom Right
				//m = diagBR(100);
				break;

			case 4: //Bottom
				m = backward(100);
				break;

			case 5: //Bottom Left
				//m = diagBL(100);
				break;

			case 6: //Left
				m = rotL(100);
				break;

			case 7: //Top Left
				//m = diagFL(100);
				break;

			default:
				break;
			}
		}

		//Super Slowmo
		if (joy1Btn(5)) {
			m = setMVals(0.1*m->fl, 0.1*m->fr, 0.1*m->bl, 0.1*m->br);
		}

		setMotor(m);

	}

}

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}
