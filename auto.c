#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorAnalogInactive)
#pragma config(Motor,  mtr_S1_C1_1,     elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     nothing,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     BR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     FL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     grabber,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     arm,           tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    sArm,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    lServo,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    sGyro,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    rServo,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//  nnnnn nn nt ty

#include "JoystickDriver.c"

#include "drivers/hitechnic-gyro.h"

#include "ref/auto_ref.h"

////////Function Prototypes
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

//Resets the initial rot speed
//Returns the current rotation
float resetGyro() {
	time1[T1] = 0;
	return HTGYROreadRot(gyro);
}

//Updates the heading
//Returns the updated heading
float updateGyro(float heading, float initialRotSpeed) {
	float rotSpeed = HTGYROreadRot(gyro);
	float dt = time1[T1];//Update time that has passed

	if((rotSpeed != initialRotSpeed) || dt >= 20) {
		print(heading);
		heading += (initialRotSpeed * (dt/1000)); //updates the heading
	}

	return heading;
}

task main()
{
	//Initialize components
	print("Initializing...");

	setMotor(0, 0, 0, 0);

	servo[rServo] = GRABBERUP;
	servo[lServo] = GRABBERUP;

	servo[sGyro] = GYRODOWN;

	//Init Gyro
	HTGYROstartCal(gyro);

	//Heading keeps track of rotation
	float heading;

	//Let stuff init for a second
	wait1Msec(1000);

	print("Ready!");

	//Now do the prompts

	//Wait for Comp. to start
#ifdef wait_for_start
	waitForStart();
#endif

	/* GO DOWN RAMP */

	//Rotate gyro to measure 3d plane
	servo[sGyro] = GYROUP;

	//Allow servo time to orient
	wait1Msec(500);

	//Time has passes, reset gyro
	float initialRotSpeed = resetGyro();

	//Reset the heading
	//Now we are in the other plane, so a 0 heading indicates we are flat
	heading = 0;

	//Update the heading
	heading = updateGyro(heading, initialRotSpeed);
	initialRotSpeed = resetGyro();

	while(heading < 2) {
		heading = updateGyro(heading, initialRotSpeed);

		initialRotSpeed = resetGyro();

		setMotor(forward(100));
	}

	while(heading > 1) {
		heading = updateGyro(heading, initialRotSpeed);

		initialRotSpeed = resetGyro();

		setMotor(forward(100));
	}

	setMotor(0, 0, 0, 0);

	//Re-set up
	servo[sGyro] = GYRODOWN;

	wait1Msec(300);
	setMotor(forward());
	wait1Msec(300);

	setMotor(0,0,0,0);
}

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}
