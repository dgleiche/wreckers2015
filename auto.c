#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX1,        sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX2,        sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     elevator,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    armHatch,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    lServo,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    rServo,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//TODO: ADD TIMEOUTS TO EVERYTHING. NO JOKE. EVERYTHING.

#include "JoystickDriver.c"

#include "/ref/auto_ref.h"

/* 3rd Party Drivers */
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"
#include "drivers/lego-ultrasound.h"

/* Sensors on multiplexor */
//Multiplexor 1
const tMUXSensor gyroX = msensor_S2_1;
const tMUXSensor elevatorTouch = msensor_S2_2;
const tMUXSensor sonar = msensor_S2_3;
const tMUXSensor ir = msensor_S2_4;

//Multiplexor 2
const tMUXSensor gyroZ = msensor_S3_1;
const tMUXSensor color = msensor_S3_2;

/* Constants */
//General correction factor for auto
const int CF = 2.5;

/* Typedefs */
typedef enum {
	BLUE1 = 2,
	BLUE2 = 3,
	RED1 = 8,
	RED2 = 9,
	GRAY1 = 14,
	GRAY2 = 17
} Colors;

typedef enum {
	BLUE,
	RED
} TeamColors;

/* Global variables */
//headingX will store heading in the x plane while headingZ stores heading in the z plane
float headingX = 0;
float headingZ = 0;

///Global Variables set with prompts
TeamColors teamColor;

/* Function Prototypes */

//Overload our setMotor function to allow two different ways to input the motor value
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

//Easily set value of grabber servo
void setGrabberServo(int val);

//Quickly reset heading so we can turn and stuff using gyro
void resetHeadingX();
void resetHeadingZ();

//Make sure bot goes straight
mVals *gyroFixHeading(mVals *m, float cf);

/* Function Prototypes for actual autonomous objectives */
//Off ramp objectives
void ir0();

//Ramp Objectives
void getDownRamp();

/* Asynchronous tasks */

//Continously updates the heading
task updateHeadingX() {

	HTGYROstartCal(gyroX);

	float prevRate = 0.0;
	float curRate = 0.0;
	float dt = 0.0;
	time1[T1] = 0;

	while (true) {
		prevRate = curRate;
		dt = (float)time1[T2]/(float)1000.0; // msec to sec
		time1[1] = 0;
		curRate = (float)HTGYROreadRot(gyroX);
		headingX += ((float)prevRate+(float)curRate)*(float)0.5*(float)dt;
		wait1Msec(1);
	}
}

task updateHeadingZ() {

	HTGYROstartCal(gyroZ);

	float prevRate = 0.0;
	float curRate = 0.0;
	float dt = 0.0;
	time1[T1] = 0;

	while (true) {
		prevRate = curRate;
		dt = (float)time1[T2]/(float)1000.0; // msec to sec
		time1[1] = 0;
		curRate = (float)HTGYROreadRot(gyroZ);
		headingZ += ((float)prevRate+(float)curRate)*(float)0.5*(float)dt;
		wait1Msec(1);
	}
}


task initialize() {
	//Initialize components
	print("Initializing...");

	PlaySound(soundBeepBeep);

	setMotor(stopMotors());

	//Initialize the tube grabber servos up
	setGrabberServo(GRABBERUP);

	//Let stuff init for a second
	wait1Msec(1000);

	StartTask(updateHeadingX);
	//StartTask(updateHeadingZ);

	print("Ready!");
}

/* TASKS FOR OFF RAMP AUTO */

task main()
{
	//Initialize
	//This will also start a task to asynchronously update the heading
	StartTask(initialize);

	#ifdef wait_for_start
		waitForStart();
	#endif

	ir0();
}

/* FUNCTIONS FOR OFF RAMP AUTO */
//When beacon is 0Deg from robot
void ir0() {
	//resetHeadingX();

	while (true) {
		print(USreadDist(sonar));
	}
}

/* FUNCTIONS FOR RAMP AUTO */

void getDownRamp() {
	//We reset the heading b/c we're about to use the gyro to know when we're on the ramp
	resetHeadingZ();

	//TODO: THESE VALUES ARE WAAAAAAAY OFF IM ASSUMING. EVERYTHING THAT CAN GO WRONG WILL GO WRONG
	//Thresholds for gyro knowing when we're on and off the ramp
	//By on ramp I mean like have't reached the down the ramp part
	const float onRampThreshold = 45;
	const float offRampThreshold = -45;

	//While the heading is less than threshold we havn't made it to the down the ramp part (I know real intuitive)
	while(headingZ < onRampThreshold) {
		setMotor(forward(100));
	}

	//New objective with gyro means new heading
	resetHeadingZ();

	//While the heading is greater than the threshold we haven't made it off the ramp
	while(headingZ < offRampThreshold) {
		setMotor(forward(100));
	}

	//And you have arrived safely at your destination of off the ramp (allegedly)
	setMotor(stopMotors());
}

/*
void alignToLine(Colors color, int timesToAlign) {

	int speed = 20;

	Colors color1 = (color == RED) ? (short)RED1 : (short)BLUE1;
	Colors color2 = (color == RED) ? (short)RED2 : (short)BLUE2;

	bool front_aligned = false;
	bool back_aligned = false;

	mVals motorVals;

	float timesAligned = 0;

	while (timesAligned < timesToAlign) {

		if(HTCS2readColor(colorL) == (short)GRAY1 || HTCS2readColor(colorR) == (short)GRAY2) {
			motorVals.fl = -speed;
			motorVals.fr = speed;
		}
		else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
			motorVals.fl = speed;
			motorVals.fr = -speed;
		}
		else {
			front_aligned = true;
			motorVals.fl = 0;
			motorVals.fr = 0;
		}

		if(HTCS2readColor(colorL) == (short)GRAY1 || HTCS2readColor(colorR) == (short)GRAY2) {
			motorVals.bl = speed;
			motorVals.br = -speed;
		}
		else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
			motorVals.bl = -speed;
			motorVals.br = speed;
		}
		else {
			back_aligned = true;
			motorVals.bl = 0;
			motorVals.br = 0;
		}

		setMotor(motorVals);

		//Repeat the function again because the robot hasn't corrected enough times yet [?: wait before second correct?]
		if(front_aligned == true && back_aligned == true) {
			front_aligned = false;
			back_aligned = false;
			timesAligned += 1;
		}

	}
} */

/* Misc. Functions */
mVals *gyroFixHeading(mVals *m, float cf) {
	//Motor powers are adjusted by this value (based on heading and correction factor)
	float adjusted_val = headingX * cf;

	//Store corrected motor vals
	mVals newM;

  newM.fl = m->fl - adjusted_val;
	newM.fr = m->fr + adjusted_val;
	newM.bl = m->bl - adjusted_val;
	newM.br = m->br + adjusted_val;

	return newM;
}

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}

void setGrabberServo(int val) {
	servo[lServo] = val;
	servo[rServo] = 255-val;
}

void resetHeadingX() {
	headingX = 0;
}

void resetHeadingZ() {
	headingZ = 0;
}
