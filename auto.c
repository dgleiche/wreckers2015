#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     BR,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BL,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    collectorDoor,        tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    rServo,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    lServo,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    sGyro,                tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//TODO: ADD TIMEOUTS TO EVERYTHING. NO JOKE. EVERYTHING.

#include "JoystickDriver.c"

#include "/ref/auto_ref.h"

/* 3rd Party Drivers */
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"

/* Sensors on multiplexor */
const tMUXSensor ir = msensor_S2_1;
const tMUXSensor gyro = msensor_S2_2;
const tMUXSensor colorR = msensor_S2_3;
const tMUXSensor colorL = msensor_S2_4;


/* Typedefs */
typedef enum {
	BLUE,
	RED
} TeamColors;

/* Global variables */
//curHeading will store the heading of the gyro between -360 to +360 degrees (yes I know I'm a pleb for using degrees)
int curHeading = 0;

///Global Variables set with prompts
TeamColors teamColor;

/* Function Prototypes */

//Overload our setMotor function to allow two different ways to input the motor value
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

//Easily set value of grabber servo
void setGrabberServo(int val);

//Quickly reset heading so we can turn and stuff using gyro
void resetHeading();

/* Function Prototypes for actual autonomous objectives */

void getDownRamp();

//alignToLine will be reused in order to align to different lines with color sensor
void alignToLine(TeamColors color);

/* Asynchronous tasks */

//Continously updates the heading
task updateHeading() {
	float delTime = 0;
	float prevHeading = 0;
	float curRate = 0;

  HTGYROstartCal(gyro);
  PlaySound(soundBeepBeep);
  while (true) {
    time1[T1] = 0;
    curRate = HTGYROreadRot(gyro);

    //If the current rate of the gyro is greater than a threshold, there is movement
    if (abs(curRate) > 3) {
      prevHeading = curHeading;
      curHeading = prevHeading + curRate * delTime;

      //Ensure the heading is within bounds
      if (curHeading > 360)
      	curHeading -= 360;
      else if (curHeading < 0)
      	curHeading += 360;
    }
    wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000;
  }
}

task initialize() {
	//Initialize components
	print("Initializing...");

	setMotor(stopMotors());

	//Initialize the tube grabber servos up
	setGrabberServo(GRABBERUP);

	//Initialize the gyro servo up b/c its gonna go down the ramp
	servo[sGyro] = GYROUP;

	//Let stuff init for a second
	wait1Msec(1000);

	StartTask(updateHeading);

	print("Ready!");
}

task main()
{
	//Initialize
	//This will also start a task to asynchronously update the heading
	StartTask(initialize);

#ifdef wait_for_start
	waitForStart();
#endif

	/* GO DOWN RAMP USING GYRO */
	getDownRamp();

	/* ALIGN OURSELVES TO THE TAPE IN FRONT OF RAMP */
}

/* Functions that complete objectives */

void getDownRamp() {
	//We reset the heading b/c we're about to use the gyro to know when we're on the ramp
	resetHeading();

	//TODO: THESE VALUES ARE WAAAAAAAY OFF IM ASSUMING. EVERYTHING THAT CAN GO WRONG WILL GO WRONG
	//Thresholds for gyro knowing when we're on and off the ramp
	//By on ramp I mean like have't reached the down the ramp part
	const float onRampThreshold = 45;
	const float offRampThreshold = -45;

	//While the heading is less than threshold we havn't made it to the down the ramp part (I know real intuitive)
	while(curHeading < onRampThreshold) {
		setMotor(forward(100));
	}

	//New objective with gyro means new heading
	resetHeading();

	//While the heading is greater than the threshold we haven't made it off the ramp
	while(curHeading < offRampThreshold) {
		setMotor(forward(100));
	}

	//And you have arrived safely at your destination of off the ramp (allegedly)
	setMotor(stopMotors());

	servo[sGyro] = GYRODOWN;
}

void alignToLine(TeamColors color) {
	if(HTCS2readColor(colorL) == gray1 || HTCS2readColor(colorR) == gray2) {
		motor[FL] = -speed;
		motor[FR] = speed;
	}
	else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
		motor[FL] = speed;
		motor[FR] = -speed;
	}
	else {
		front_aligned = true;
		motor[FL] = 0;
		motor[FR] = 0;
	}

	if(HTCS2readColor(colorL) == gray1 || HTCS2readColor(colorR) == gray2) {
		motor[BL] = speed;
		motor[BR] = -speed;
	}
	else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
		motor[BL] = -speed;
		motor[BR] = speed;
	}
	else {
		back_aligned = true;
		motor[BL] = 0;
		motor[BR] = 0;
	}

	//repeat the function again because the robot hasn't corrected enough times yet [?: wait before second correct?]
	if(front_aligned == true && back_aligned == true && correction_counter < num_times) {
		front_aligned = false;
		back_aligned = false;
		correction_counter += 1;
	}
	//robot has corrected enough times- stop aligning
	else if(front_aligned == true && back_aligned == true && correction_counter == num_times)	{
		robot_aligned = true;
	}
}

/* Misc. Functions */

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}

void setGrabberServo(int val) {
	servo[lServo] = val;
	servo[rServo] = 255-val;
}

void resetHeading() {
	curHeading = 0;
}
