#pragma config(Hubs,	S1, HTMotor,	HTMotor,	HTServo,	HTMotor)
#pragma config(Sensor, S1,		 ,							 sensorI2CMuxController)
#pragma config(Sensor, S2,		 HTSMUX,				 sensorI2CCustom)
#pragma config(Motor,	 mtr_S1_C1_1,			BL,						 tmotorTetrix, openLoop, reversed)
#pragma config(Motor,	 mtr_S1_C1_2,			FL,						 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C2_1,			collector,		 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C2_2,			elevator,			 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C4_1,			FR,						 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C4_2,			BR,						 tmotorTetrix, openLoop)
#pragma config(Servo,	 srvo_S1_C3_1,		sArmHatch,						tServoStandard)
#pragma config(Servo,	 srvo_S1_C3_2,		servo2,								tServoNone)
#pragma config(Servo,	 srvo_S1_C3_3,		servo3,								tServoNone)
#pragma config(Servo,	 srvo_S1_C3_4,		sGyro,								tServoStandard)
#pragma config(Servo,	 srvo_S1_C3_5,		lServo,								tServoStandard)
#pragma config(Servo,	 srvo_S1_C3_6,		rServo,								tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

//TODO: ADD TIMEOUTS TO EVERYTHING. NO JOKE. EVERYTHING.

#include "JoystickDriver.c"

#include "/ref/auto_ref.h"

/* 3rd Party Drivers */
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"

/* Sensors on multiplexor */
const tMUXSensor gyro = msensor_S2_1;
const tMUXSensor colorF = msensor_S2_2;
const tMUXSensor colorR = msensor_S2_3;
const tMUXSensor colorL = msensor_S2_4;


/* Typedefs */
typedef enum {
	BLUE1 = 2,
	BLUE2 = 3,
	RED1 = 8,
	RED2 = 9,
	GRAY1 = 14,
	GRAY2 = 17
} Colors;

typedef enum {
	BLUE,
	RED
} TeamColors;

/* Global variables */
//curHeading will store the heading of the gyro between -360 to +360 degrees (yes I know I'm a pleb for using degrees)
float heading = 0;

///Global Variables set with prompts
TeamColors teamColor;

/* Function Prototypes */

//Overload our setMotor function to allow two different ways to input the motor value
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

//Easily set value of grabber servo
void setGrabberServo(int val);

//Quickly reset heading so we can turn and stuff using gyro
void resetHeading();

/* Function Prototypes for actual autonomous objectives */

void getDownRamp();

//alignToLine will be reused in order to align to different lines with color sensor
void alignToLine(Colors color, int timesToAlign);

/* Asynchronous tasks */

//Continously updates the heading
task updateHeading() {

	HTGYROstartCal(gyro);

	PlaySound(soundBeepBeep);

	float prevRate = 0.0;
	float curRate = 0.0;
	float dt = 0.0;
	time1[T1] = 0;

	while (true) {
		prevRate = curRate;
		dt = (float)time1[T2]/(float)1000.0; // msec to sec
		time1[1] = 0;
		curRate = (float)HTGYROreadRot(gyro);
		heading += ((float)prevRate+(float)curRate)*(float)0.5*(float)dt;
		wait1Msec(1);
	}
}

task initialize() {
	//Initialize components
	print("Initializing...");

	setMotor(stopMotors());

	//Initialize the tube grabber servos up
	setGrabberServo(GRABBERUP);

	//Initialize the gyro servo up b/c its gonna go down the ramp
	servo[sGyro] = GYROUP;

	//Let stuff init for a second
	wait1Msec(1000);

	StartTask(updateHeading);

	print("Ready!");
}

task main()
{
	//Initialize
	//This will also start a task to asynchronously update the heading
	StartTask(initialize);

#ifdef wait_for_start
	waitForStart();
#endif

	/* GO DOWN RAMP USING GYRO */
	getDownRamp();

	/* ALIGN OURSELVES TO THE TAPE IN FRONT OF RAMP */
}

/* Functions that complete objectives */

void getDownRamp() {
	//We reset the heading b/c we're about to use the gyro to know when we're on the ramp
	resetHeading();

	//TODO: THESE VALUES ARE WAAAAAAAY OFF IM ASSUMING. EVERYTHING THAT CAN GO WRONG WILL GO WRONG
	//Thresholds for gyro knowing when we're on and off the ramp
	//By on ramp I mean like have't reached the down the ramp part
	const float onRampThreshold = 45;
	const float offRampThreshold = -45;

	//While the heading is less than threshold we havn't made it to the down the ramp part (I know real intuitive)
	while(heading < onRampThreshold) {
		setMotor(forward(100));
	}

	//New objective with gyro means new heading
	resetHeading();

	//While the heading is greater than the threshold we haven't made it off the ramp
	while(heading < offRampThreshold) {
		setMotor(forward(100));
	}

	//And you have arrived safely at your destination of off the ramp (allegedly)
	setMotor(stopMotors());

	servo[sGyro] = GYRODOWN;
}

/*
void alignToLine(Colors color, int timesToAlign) {

	int speed = 20;

	Colors color1 = (color == RED) ? (short)RED1 : (short)BLUE1;
	Colors color2 = (color == RED) ? (short)RED2 : (short)BLUE2;

	bool front_aligned = false;
	bool back_aligned = false;

	mVals motorVals;

	float timesAligned = 0;

	while (timesAligned < timesToAlign) {

		if(HTCS2readColor(colorL) == (short)GRAY1 || HTCS2readColor(colorR) == (short)GRAY2) {
			motorVals.fl = -speed;
			motorVals.fr = speed;
		}
		else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
			motorVals.fl = speed;
			motorVals.fr = -speed;
		}
		else {
			front_aligned = true;
			motorVals.fl = 0;
			motorVals.fr = 0;
		}

		if(HTCS2readColor(colorL) == (short)GRAY1 || HTCS2readColor(colorR) == (short)GRAY2) {
			motorVals.bl = speed;
			motorVals.br = -speed;
		}
		else if(HTCS2readColor(colorL) == color1 || HTCS2readColor(colorR) == color2) {
			motorVals.bl = -speed;
			motorVals.br = speed;
		}
		else {
			back_aligned = true;
			motorVals.bl = 0;
			motorVals.br = 0;
		}

		setMotor(motorVals);

		//Repeat the function again because the robot hasn't corrected enough times yet [?: wait before second correct?]
		if(front_aligned == true && back_aligned == true) {
			front_aligned = false;
			back_aligned = false;
			timesAligned += 1;
		}

	}
} */

/* Misc. Functions */

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}

void setGrabberServo(int val) {
	servo[lServo] = val;
	servo[rServo] = 255-val;
}

void resetHeading() {
	heading = 0;
}
