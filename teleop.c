#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX1,        sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX2,        sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     BL,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     FL,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     elevatorL,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     FR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     elevatorR,     tmotorTetrix, PIDControl, encoder, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    irServo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    armHatch,             tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    lServo,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    rServo,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-touch.h"

#include "ref/teleop_ref.h"

/* CONSTANTS */
//MUX Sensors
const tMUXSensor elevatorTouch = msensor_S2_2;

//Joystick threshold
const int THRESHOLD = 20;

/* GLOBALS */
elevatorPositions elevatorPosition;
bool elevatorMoving = false;

/* FUNCTION PROTOTYPES */
void setMotor(mVals *m);
void setMotor(float fl, float fr, float bl, float br);

void setGrabberServo(int val);

void moveElevatorDown();
void moveElevatorDist(elevatorPositions position);

void elevatorMotors(int power);
void resetElevatorEncoders();

/* Task Prototypes */
task btnListener();
task elevatorMove();
float a;
/* TASKS */
task elevatorMove() {

	servo[armHatch] = ARMHATCHUP;

	switch (elevatorPosition) {
		case elevatorDown:
			moveElevatorDown();
			break;
		case elevator30:
			moveElevatorDown();
			moveElevatorDist(elevator30);
			break;
		case elevator60:
			moveElevatorDown();
			moveElevatorDist(elevator60);
		case elevator120:
			moveElevatorDown();
			moveElevatorDist(elevator120);
			break;
		default:
			break;
	}
}

task btnListener() {
	bool grabCylinderDown = false;
	bool pressed3 = false;

	bool armServoDown = false;
	bool pressed1 = false;

	while(true) {

		//a is just a global var that lets us set encoder vals easily
		a = nMotorEncoder[elevatorR];

		if (nMotorEncoder[elevatorL] < 0 || nMotorEncoder[elevatorR] < 0) resetElevatorEncoders();

		getJoystickSettings(joystick);

		/* JOYSTICK 2 */
		//Elevator Presets
		if (joy2Btn(2)) {
			elevatorPosition = elevatorDown;

			//Stop the elevator task just incase
			StopTask(elevatorMove);

			StartTask(elevatorMove);
		}

		if (joy2Btn(1)) {
			elevatorPosition = elevator120;
			StopTask(elevatorMove);

			StartTask(elevatorMove);
		}

		if (joy2Btn(3)) {
			elevatorPosition = elevator30;
			StopTask(elevatorMove);

			StartTask(elevatorMove);
		}

		if (joy2Btn(4)) {
			elevatorPosition = elevator60;
			StopTask(elevatorMove);

			StartTask(elevatorMove);
		}

		//Elevator
		if (!elevatorMoving) {
			if (joy1Btn(7))
				elevatorMotors(-100);
			else if (joy1Btn(8))
				elevatorMotors(100);
			else
				elevatorMotors(0);
		} else {
			if (joy1Btn(7) || joy1Btn(8)) {
				elevatorMoving = false;
				StopTask(elevatorMove);

				elevatorMotors(0);
			}
		}

		if (joy1Btn(1)) {
			if (!pressed1) {
				if (!armServoDown) {
					armServoDown = true;
					servo[armHatch] = ARMHATCHUP;
				}
				else {
					armServoDown = false;
					servo[armHatch] = ARMHATCHDOWN;
				}
			}
			pressed1 = true;
		}
		else {
			pressed1 = false;
		}

		//Left and right cylinder collectors
		if (joy1Btn(3)) {
			if (!pressed3) {
				if (!grabCylinderDown) {
					grabCylinderDown = true;
					setGrabberServo(GRABBERDOWN);
				}
				else {
					grabCylinderDown = false;
					setGrabberServo(GRABBERUP);
				}
			}
			pressed3 = true;
		}
		else {
			pressed3 = false;
		}

		//collector intake/outake
		if (joy1Btn(2))
			motor[collector] = 100;
		else if (joy1Btn(4))
			motor[collector] = -100;
		else
			motor[collector] = 0;


	}
}



task main()
{
	//Initialize components
	setMotor(0, 0, 0, 0);

	setGrabberServo(GRABBERUP);

	servo[armHatch] = ARMHATCHUP;

	servo[irServo] = IRDOWN;

	resetElevatorEncoders();

	//Wait for Comp. to start
#ifdef wait_for_start
	waitForStart();
#endif

	StartTask(btnListener);

	//Main loop
	while(true) {
		getJoystickSettings(joystick);

		/////////////////////////////JOYSTICK MOVEMENT//////////////////////////

		//Vals on joy1_x/y1 will be translatational
		float tX = joystick.joy1_x1;
		float tY = joystick.joy1_y1;

		//Val on joy1_x2 will be for x rotation
		float rotX = joystick.joy1_x2;


		//Var to hold motor vals
		mVals *m;
		//clearDebugStream();

		//No unwanted movement
		m = (abs(tX) > THRESHOLD || abs(tY) > THRESHOLD || abs(rotX) > THRESHOLD) ? calcJoyMove(tX, tY, rotX) : setMVals(0, 0, 0, 0);

		////////////////////////D PAD MOVEMENT//////////////////////////////
		//D Pad will always override joystick
		//Check to see if top hat isnt centered (centered yields -1
		if (joystick.joy1_TopHat != -1) {

			switch (joystick.joy1_TopHat) {
			case 0: //Top
				m = forward(100);
				break;

			case 1: //Top Right
				m = diagFR(100);
				break;

			case 2: //Right
				m = strafeR(100);
				break;

			case 3: //Bottom Right
				m = diagBR(100);
				break;

			case 4: //Bottom
				m = backward(100);
				break;

			case 5: //Bottom Left
				m = diagBL(100);
				break;

			case 6: //Left
				m = strafeL(100);
				break;

			case 7: //Top Left
				m = diagFL(100);
				break;

			default:
				break;
			}
		}

		setMotor(m);

	}

}

/* Functions */

//ELevator Movements
void elevatorMotors(int power) {
	motor[elevatorL] = power;
	motor[elevatorR] = power;
}

void resetElevatorEncoders() {
	nMotorEncoder[elevatorL] = 0;
	nMotorEncoder[elevatorR] = 0;
}

void moveElevatorDown() {
	elevatorMoving = true;
	while(!TSreadState(elevatorTouch)) {
		elevatorMotors(-100);
	}

	elevatorMotors(0);
	resetElevatorEncoders();

	elevatorMoving = false;
}

void moveElevatorDist(elevatorPositions position) {
	elevatorMoving = true;
	while(nMotorEncoder[elevatorR] < position) {
		elevatorMotors(50);
	}

	elevatorMotors(0);

	elevatorMoving = false;
}

void setGrabberServo(int val) {
	servo[lServo] = val;
	servo[rServo] = 280-val;
}

void setMotor(mVals *m) {
	//Pass along to func with the four motor vals
	setMotor(m->fl, m->fr, m->bl, m->br);
}

void setMotor(float fl, float fr, float bl, float br) {
	motor[FL] = fl;
	motor[FR] = fr;
	motor[BL] = bl;
	motor[BR] = br;
}
